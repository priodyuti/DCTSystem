/home/gautam/DCTSystem/.vscode/c_cpp_properties.json
{
    "configurations": [
        {
            "name": "Linux",
            "includePath": [
                "${workspaceFolder}/**",
                "/usr/include/c++/9"
            ],
            "defines": [],
            "compilerPath": "/usr/bin/gcc",
            "cStandard": "gnu17",
            "cppStandard": "gnu++14",
            "intelliSenseMode": "linux-gcc-x64"
        }
    ],
    "version": 4
}


/home/gautam/DCTSystem/.vscode/launch.json
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(gdb) Launch",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/DCTSystem",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${fileDirname}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "g++ build active file",
            "miDebuggerPath": "/usr/bin/gdb"
        }
    ]
}

/home/gautam/DCTSystem/.vscode/tasks.json
{
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    "version": "2.0.0",
    "tasks": [
        {
            "type": "shell",
            "label": "g++ build active file",
            "command": "/usr/bin/g++",
            "args": ["-g", "${workspaceFolder}/src/*.cpp", "-o", "${workspaceFolder}/DCTSystem"],
            "options": {
              "cwd": "/usr/bin"
            },
            "problemMatcher": ["$gcc"],
            "group": {
              "kind": "build",
              "isDefault": true
            }
        }
    ]
}

bool Phi::GetCVID(long parSID, long parDID, unsigned long long& parCVID){
    if ((parSID == -1 || parDID==-1) || (parSID >= N || parDID >= N)){
        std::cout<<"Error in Phi::GetCVID():-Invalid user ID(s)"<<std::endl;
        return false;
    }
    std::fstream PhiFPtr;
    PhiFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    PhiRec R;
    unsigned int RSize=R.Size();
    PhiRecOverflow R1;
    unsigned int R1Size=R1.Size();
    unsigned long long Pos=0, PhiOvRecIndex;
    unsigned long long NoOfPhiRecRead=0;
    parCVID = 0;
    try{
        PhiFPtr.open(PhiFileName, ios::in | ios::binary);
        if (PhiFPtr.fail()) throw PhiFileName;  // the exception being checked

        PhiFPtr.read((char*)&NoOfPhiRecRead, sizeof(NoOfPhiRecRead));
        if (NoOfPhiRecRead != NoOfPhiRec){
            PhiFPtr.close();
            std::cout << "Error in Phi::GetCVID():- mismatch in number of records" << std::endl;
            std::exit(1);
        }
        Pos = (long long)(parSID * q * 2 * RSize + sizeof(unsigned long long));
        //std::cout<<"\nPhi::GetCVID():Pos="<<Pos<<" parSID="<<parSID<<" q="<<q<<" R.Size()="<<R.Size()<<std::endl;
        //std::cout<<"\nPhiFPtr.tellg()="<<PhiFPtr.tellg()<<std::endl;
        PhiFPtr.seekg(Pos, ios::beg);
        //std::cout<<"\nPhiFPtr.tellg()="<<PhiFPtr.tellg()<<std::endl;
        for (unsigned int i = 0; i < ((2*q)-1); i++){
            PhiFPtr.read((char*)&R, RSize);
            std::cout<<"Phi::GetCVID:- R(PhiRec)="<<R<<std::endl;
            //Next record has deleted status true, then no more contact record is available for the current user
            if (R.GetDelFlag()){
                std::cout<<"\nPhi::GetCVID:-user("<<parDID<<")not in contact with user("<<parSID<<")"<<std::endl;
                PhiFPtr.close();
                return false;
            }
            if (R.GetNeighborID() == parDID){
                std::cout<<"Phi::GetCVID:-user("<<parDID<<")in contact with user("<<parSID<<")"<<std::endl;
                parCVID = R.GetCVID();
                std::cout<<"Phi::GetCVID:- with CVID="<<parCVID<<std::endl;
                PhiFPtr.close();
                return true;
            }
        }
        //if(i < ((2*q)-1))return true;
        PhiFPtr.read((char*)&R, RSize);
        if (R.GetDelFlag()){
            std::cout<<"\nPhi::GetCVID:-user("<<parDID<<")not in contact with user("<<parSID<<")"<<std::endl;
            PhiFPtr.close();
            return false;
        }
        else PhiOvRecIndex = R.GetCVID();//last record stores the index of 1st overflow record 
        Pos = (long long)(NoOfPhiRec * RSize + sizeof(unsigned long long));
        /*
        In this overflow area one separate linked list structure is maintained for each indevidual
        for whom overflow records are needed.
        For the last node in the list Forward Link (FLink) is negative. 
        */
        while(true)
        {
            PhiFPtr.seekg(Pos + PhiOvRecIndex * R1Size, ios::beg);
            PhiFPtr.read((char*)&R1, R1Size);
            if (R1.GetNeighborID() == parDID){
                std::cout<<"Phi::GetCVID:-user("<<parDID<<")in contact with user("<<parSID<<")"<<std::endl;
                parCVID = R1.GetCVID();
                std::cout<<"Phi::GetCVID:- with CVID="<<parCVID<<std::endl;
                PhiFPtr.close();
                break;
            }
            PhiOvRecIndex = R1.GetNext();
            if (PhiOvRecIndex < 0){
                PhiFPtr.close();
                std::cout<<"\nPhi::GetCVID:-user("<<parDID<<")not in contact with user("<<parSID<<")"<<std::endl;
                return false;
            }
        }
    }
    catch (std::fstream::failure &e){
        std::cerr << "Phi::GetCVID() - Exception opening/reading/closing file\n";
        std::exit(1);
    }
    catch (std::string e){
        std::cout << "Phi::GetCVID() " << e << " error in opening/creating" << std::endl;
        std::exit(1);
    }
    catch (std::out_of_range& e){
        std::cout << "Phi::GetCVID() " << e.what() << " Not in range" << std::endl;
        std::exit(1);
    }
    catch (std::bad_alloc& e){
        std::cout << "Phi::GetCVID() " << e.what() << " bad allocation" << std::endl;
        std::exit(1);
    }
    catch (std::exception& e){
        std::cout << "Phi::GetCVID() " << e.what() << "Exception occur" << std::endl;
        std::exit(1);
    }
}

bool Phi::GetCVID(unsigned long long parPHiRecIndex, bool parOvFlag, 
    unsigned long long& parCVID, long &parSID, long &parDID){
    if(!parOvFlag){
        if(parPHiRecIndex < 0 || parPHiRecIndex > NoOfPhiRec){
            std::cout << "Error in Phi::GetCVID():- invalid Phi Record Index" << std::endl;
            std::exit(1);
        }
    }
    else{
        if(parPHiRecIndex < 0 || parPHiRecIndex > NoOfPhiOvRec){
            std::cout << "Error in Phi::GetCVID():- invalid Phi Record Index" << std::endl;
            std::exit(1);
        }
    }
    std::fstream PhiFPtr;
    PhiFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    PhiRec R;
    unsigned int RSize=R.Size();
    PhiRecOverflow R1;
    unsigned int R1Size=R1.Size();
    unsigned int Q = ceil(f * q);
    unsigned long long Pos=0,NoOfPhiRecRead;
    parCVID = 0;
    try{
        PhiFPtr.open(PhiFileName, ios::in | ios::binary);
        if (PhiFPtr.fail()) throw PhiFileName;  // the exception being checked

        PhiFPtr.read((char*)&NoOfPhiRecRead, sizeof(NoOfPhiRecRead));
        if (NoOfPhiRecRead != NoOfPhiRec){
            PhiFPtr.close();
            std::cout << "Error in Phi::GetCVID():- mismatch in number of records" << std::endl;
            std::exit(1);
        }
        if(!parOvFlag){
            parSID = (parPHiRecIndex / Q);
            Pos = (long long)((1 + 2 * parSID) * sizeof(unsigned long long) + parPHiRecIndex * RSize);
            PhiFPtr.seekg(Pos, ios::beg);
            PhiFPtr.read((char *)&R, RSize);
            PhiFPtr.close();
            if(R.GetDelFlag()==false && R.GetUpdateFlag()==false){
                parCVID = R.GetCVID();
                parDID = R.GetNeighborID();
                parSID = (parPHiRecIndex / (2 * q));
            }
            else{
                std::cout << "Error in Phi::GetCVID():- mismatch in number of records" << std::endl;
                std::exit(1);
            }
        }
        else{
            Pos = (long long)(sizeof(unsigned long long) + NoOfPhiRec * RSize
                + parPHiRecIndex * R1Size);
            PhiFPtr.seekg(Pos, ios::beg);
            PhiFPtr.read((char *)&R1, R1Size);
            PhiFPtr.close();
            if(R1.GetDelFlag()==false && R1.GetUpdateFlag()==false){
                parCVID = R1.GetCVID();
                parDID = R1.GetNeighborID();
                parSID = R1.GetHostID();
            }
            else{
                std::cout << "Error in Phi::GetCVID():- mismatch in number of records" << std::endl;
                std::exit(1);
            }
        }
        return true;
    }
    catch (std::fstream::failure &e){
        std::cerr << "Phi::GetCVID() - Exception opening/reading/closing file\n";
        std::exit(1);
    }
    catch (std::string e){
        std::cout << "Phi::GetCVID() " << e << " error in opening/creating" << std::endl;
        std::exit(1);
    }
    catch (std::out_of_range& e){
        std::cout << "Phi::GetCVID() " << e.what() << " Not in range" << std::endl;
        std::exit(1);
    }
    catch (std::bad_alloc& e){
        std::cout << "Phi::GetCVID() " << e.what() << " bad allocation" << std::endl;
        std::exit(1);
    }
    catch (std::exception& e){
        std::cout << "Phi::GetCVID() " << e.what() << "Exception occur" << std::endl;
        std::exit(1);
    }
}


bool Phi::Insert(long parSID, long parDID, unsigned long long parCVID){
    if (parSID == -1 || parDID==-1){
        std::cout<<"Error in Phi::Insert()- Invalid user ID(s)"<<std::endl;
        return false;
    }
    std::fstream PhiFPtr;
    PhiFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    PhiRec R;
    unsigned int RSize = R.Size();
    PhiRecOverflow R1,R2;
    unsigned int R1Size = R1.Size();
    unsigned long long Pos;
    unsigned long long NoOfPhiRecRead;
    unsigned long long PhiOvRecIndex, PhiOvRecIndex1;
    try{
        PhiFPtr.open(PhiFileName, ios::in | ios::binary);
        if (PhiFPtr.fail()) throw PhiFileName;  // the exception being checked
        PhiFPtr.close();

        PhiFPtr.open(PhiFileName, ios::in | ios::out | ios::binary);
        if (PhiFPtr.fail()) throw PhiFileName;  // the exception being checked

        PhiFPtr.read((char*)&NoOfPhiRecRead, sizeof(NoOfPhiRecRead));
        std::cout<<"Phi::Insert()-NoOfPhiRecRead="<<NoOfPhiRecRead<<std::endl;

        if (NoOfPhiRecRead != NoOfPhiRec){
            PhiFPtr.close();
            std::cout << "Error in Phi::Insert():- mismatch in number of records" << std::endl;
            std::exit(1);
        }
        //Move directly into the area of adjacent nodes for Individual with ID in parSID
        Pos = (long long)(sizeof(unsigned long long) + (parSID * 2 * q) * RSize);
        PhiFPtr.seekg(Pos, ios::beg);
        std::cout<<"Phi::Insert():-PhiFPtr.tellg()"<<PhiFPtr.tellg()<<std::endl;
        unsigned int i;
        //Do searching all possible (2 * q) number of adjacent nodes except except last one.
        //(2 * q)th record stores the address of the first adjacent node of the overflow area.
        //Here the field for CVID stores the index of the starting overflow record. 
        for (i = 0; i < ((2 * q)-1); i++){
            PhiFPtr.read((char*)&R, RSize);
            //Next record has deleted status true, then no more contact record is available for the current user
            if (R.GetDelFlag()) {
                std::cout<<"Phi::Insert():-Got an Empty R(PhiRec)="<<R<<std::endl;
                break;
            }
            if (R.GetNeighbor() == parDID){
                PhiFPtr.close();
                std::cout << "Error in Phi::Insert():-Duplicate Contact Entry" << endl;
                return false;
            }
        }
        //To be saved in the overflow area
        if (i == ((2 * q)-1)){
            //Get a node i.e. index of the free overflow record
            //If not available then create it. Use the insert at the starting position technique.
            //Here this last node working as starting pointer.
            //Here two-ways linked representation is used.
            if (!GetNode(PhiOvRecIndex)){
                std::cout << "Error in Phi::Insert()-Free Phi Overflow Record is not available"<<std::endl;
                return false;
            }
            else {
                //Free Phi Overflow Record is available, now read it for all updates
                Pos = (long long)((NoOfPhiRec * RSize) + sizeof(unsigned long long));
                PhiFPtr.seekg(Pos + PhiOvRecIndex * R1Size, ios::beg);
                PhiFPtr.read((char*)&R1, R1Size);
                R1.SetPrevious(-1L);//BLink of starting node is NULL 
                R1.SetCVID(parCVID);
                R1.SetNeighborID(parDID);
                R1.SetHostID(parSID);
                R1.SetDelFlag(false);
                R1.SetUpdateFlag(false);
            }
            //Read the last record for present individual
            Pos = (long long)(sizeof(unsigned long long) + ((parSID + 1) * (2 * q) - 1) * RSize);
            PhiFPtr.seekg(Pos, ios::beg);
            PhiFPtr.read((char*)&R, RSize);
            if (R.GetDelFlag()){
                //Empty overflow list
                R1.SetNext(-1L); //FLink of this single overflow record is NULL   
            }
            else {
                //Fetch the index of the present starting node
                PhiOvRecIndex1 = R.GetCVID();
                R1.SetNext(PhiOvRecIndex1); //FLink of this single overflow record is NULL   
                //Do the necessary updation for earlier starting node
                //Set the base for the overflow area and read the free overflow record
                Pos = (long long)((NoOfPhiRec * RSize) + sizeof(unsigned long long));
                PhiFPtr.seekg(Pos + PhiOvRecIndex1 * R1Size, ios::beg);
                PhiFPtr.read((char*)&R2, R1Size);
                R2.SetPrevious(PhiOvRecIndex);
                PhiFPtr.seekg(Pos + PhiOvRecIndex1 * R1Size, ios::beg);
                PhiFPtr.write((char*)&R2, R1Size);
            }
            //Set the base for the overflow area and read the free overflow record
            Pos = (long long)((NoOfPhiRec * RSize) + sizeof(unsigned long long));
            PhiFPtr.seekg(Pos + PhiOvRecIndex * R1Size, ios::beg);
            PhiFPtr.write((char*)&R1, R1Size);

            //Do the necessary updation of the header or start pointer
            R.SetCVID(PhiOvRecIndex);//Start pointer points to new node as starting node
            Pos = (long long)(sizeof(unsigned long long) + ((parSID + 1) * (2 * q) - 1) * RSize);
            PhiFPtr.seekg(Pos, ios::beg);
            PhiFPtr.write((char*)&R, RSize);
            PhiFPtr.close();
        }
        else {
            //
            Pos = (long long)(sizeof(unsigned long long) + (parSID * (2 * q) + i) * RSize);
            //One record back from current position also be possible 
            PhiFPtr.seekp(Pos, ios::beg);
            R.SetCVID(parCVID);
            R.SetNeighbor(parDID);
            R.SetDelFlag(false);
            R.SetUpdateFlag(false);
            PhiFPtr.write((char*)&R, RSize);
            PhiFPtr.close();
        }
        return true;
    }
    catch (std::fstream::failure &e){
        std::cerr << "Phi::Insert()  - Exception opening/reading/closing file\n";
        std::exit(1);
    }
    catch (std::string e){
        std::cout << "Phi::Insert() " << e << " error in opening/creating" << std::endl;
        std::exit(1);
    }
    catch (std::out_of_range& e){
        std::cout << "Phi::Insert() " << e.what() << " Not in range" << std::endl;
        std::exit(1);
    }
    catch (std::bad_alloc& e){
        std::cout << "Phi::Insert() " << e.what() << " bad allocation" << std::endl;
        std::exit(1);
    }
    catch (std::exception& e){
        std::cout << "Phi::Insert() " << e.what() << "Exception occur" << std::endl;
        std::exit(1);
    }
}

/*
class UsedCVIDRec
{
private:
    unsigned long long CVID;
    unsigned long UID1;
    bool OvFlag1;
    unsigned long UID2;
    bool OvFlag2;
    bool UpdateFlag;
public:
    UsedCVIDRec();
    UsedCVIDRec(unsigned long long parCVID, unsigned long parUID1, bool parOvFlag1, 
    unsigned long parUID2, bool parOvFlag2, bool parUpdateFlag);
    friend ostream& operator<<(ostream& parOut, const UsedCVIDRec& parUCVIDRec);
    unsigned long long GetCVID();
    bool SetCVID(unsigned long long parCVID);

    unsigned long GetUID1();
    bool SetUID1(unsigned long parUID);
    unsigned long GetUID2();
    bool SetUID2(unsigned long parUID);

    bool GetOvFlag1();
    void SetOvFlag1(bool parIsOvFlag1);
    bool GetOvFlag2();
    void SetOvFlag2(bool parIsOvFlag2);
    bool GetUpdateFlag();
    void SetUpdateFlag(bool parUpdateFlag);
    unsigned int Size();
};
*/

/*
unsigned long long Theta::GetNoOfUsedCVID()
{
    std::fstream ThetaHeaderFPtr;
    ThetaHeaderFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    std::fstream UsedCVFPtr;
    UsedCVFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    unsigned long long NoOfUsedContactVectorsRead;
    try
    {
        ThetaHeaderFPtr.open(ThetaFileHeaderName, ios::in | ios::binary);
        if (ThetaHeaderFPtr.fail()) throw ThetaFileHeaderName;  // the exception being checked
        ThetaHeaderFPtr.close();

        UsedCVFPtr.open(UsedCVListFileName, ios::in | ios::binary);
        if (UsedCVFPtr.fail()) throw UsedCVListFileName;  // the exception being checked   
        
        UsedCVFPtr.read((char *)&NoOfUsedContactVectorsRead, sizeof(NoOfUsedContactVectorsRead));
        UsedCVFPtr.close();
        if(NoOfUsedContactVectors != NoOfUsedContactVectorsRead)
        {
            std::cout << "Error in Theta::GetNoOfUsedCVID() - mismatch in the record count" << std::endl;
            std::exit(1);
        }
        return NoOfUsedContactVectors;
    }
    catch (std::fstream::failure &e)
    {
        std::cerr << "Theta::GetNoOfUsedCVID() " << e.what() << "- Exception opening/reading/closing file\n" << std::endl;
        std::exit(1);
    }
    catch(const std::exception& e)
    {
        std::cerr << "Theta::GetNoOfUsedCVID() " << e.what() << " - Exception\n";
        std::exit(1);
    }
//     catch (std::bad_alloc& e)
//     {
//         std::cout << "Theta::GetNoOfUsedCVID() " << e.what() << " bad allocation" << std::endl;
//         std::exit(1);
//     }    
 }
*/

/*
bool Theta::GetUsedCVIDRec(unsigned long long parID, UsedCVIDRec &parUsedCVIDRec)
{
    if (parID < 0 || parID > NoOfContactVectors)
    {
        std::cout<<"Error in Theta::GetUsedCVIDRec() - invalid UsedCVIDRec ID"<<std::endl;
        return false;
    }
    std::fstream UsedCVFPtr;
    UsedCVFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    unsigned long long NoOfUsedContactVectorsRead;
    unsigned long long Pos;
    try
    {
        UsedCVFPtr.open(UsedCVListFileName, ios::in | ios::binary);
        if (UsedCVFPtr.fail()) throw UsedCVListFileName;  // the exception being checked   
        
        UsedCVFPtr.read((char *)&NoOfUsedContactVectorsRead, sizeof(NoOfUsedContactVectorsRead));
        if(NoOfUsedContactVectors != NoOfUsedContactVectorsRead)
        {
            UsedCVFPtr.close();
            std::cout << "Error in Theta::GetUsedCVIDRec() - mismatch in the record count" << std::endl;
            std::exit(1);
        }
        if (parID >= NoOfUsedContactVectors)
        {
            UsedCVFPtr.close();
            std::cout<<"Error in Theta::GetUsedCVIDRec() - invalid UsedCVIDRec ID"<<std::endl;
            return false;
        }
        Pos = parID*parUsedCVIDRec.Size() + sizeof(NoOfUsedContactVectors);
        UsedCVFPtr.seekg(Pos, ios::beg);
        UsedCVFPtr.read((char *)&parUsedCVIDRec, sizeof(parUsedCVIDRec));
        UsedCVFPtr.close();
        return true;
    }
    catch (std::fstream::failure &e)
    {
        std::cerr << "Theta::RemoveLastUsedCVIDRec() " << e.what() << "- Exception opening/reading/closing file\n" << std::endl;
        std::exit(1);
    }
    catch(const std::exception& e)
    {
        std::cerr << "Theta::RemoveLastUsedCVIDRec() " << e.what() << " - Exception\n";
        std::exit(1);
    }
}
*/
/*
bool Theta::RemoveLastUsedCVIDRec(UsedCVIDRec &parUsedCVIDRec)
{
    std::fstream ThetaHeaderFPtr;
    ThetaHeaderFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    std::fstream UsedCVFPtr;
    UsedCVFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    unsigned long long NoOfUsedContactVectorsRead;
    unsigned long long Pos;
    try
    {
        ThetaHeaderFPtr.open(ThetaFileHeaderName, ios::in | ios::binary);
        if (ThetaHeaderFPtr.fail()) throw ThetaFileHeaderName;  // the exception being checked
        ThetaHeaderFPtr.close();

        UsedCVFPtr.open(UsedCVListFileName, ios::in | ios::binary);
        if (UsedCVFPtr.fail()) throw UsedCVListFileName;  // the exception being checked   
        
        UsedCVFPtr.read((char *)&NoOfUsedContactVectorsRead, sizeof(NoOfUsedContactVectorsRead));
        if(NoOfUsedContactVectors != NoOfUsedContactVectorsRead)
        {
            std::cout << "Error in Theta::RemoveLastUsedCVIDRec() - mismatch in the record count" << std::endl;
            std::exit(1);
        }
        UsedCVFPtr.close();
        if (NoOfUsedContactVectors == 0) return false;
        
        UsedCVFPtr.open(UsedCVListFileName, ios::in | ios::out | ios::binary);
        if (UsedCVFPtr.fail()) throw UsedCVListFileName;  // the exception being checked   

        Pos = (NoOfUsedContactVectors-1)*parUsedCVIDRec.Size() + sizeof(NoOfUsedContactVectors); 
        UsedCVFPtr.seekg(Pos, ios::beg);
        UsedCVFPtr.read((char *)&parUsedCVIDRec, sizeof(parUsedCVIDRec));
        
        NoOfUsedContactVectors--;
        UsedCVFPtr.seekp(0,ios::beg);
        UsedCVFPtr.write((char *)&NoOfUsedContactVectors, sizeof(NoOfUsedContactVectors));
        UsedCVFPtr.close();

        ThetaHeaderFPtr.open(ThetaFileHeaderName, ios::in | ios::out | ios::binary);
        if (ThetaHeaderFPtr.fail()) throw ThetaFileHeaderName;  // the exception being checked

        ThetaHeaderFPtr.seekp(0, ios::beg);
        ThetaHeaderFPtr.write((char *)this, sizeof(Theta));
        ThetaHeaderFPtr.close();
        return true;
    }
    catch (std::fstream::failure &e)
    {
        std::cerr << "Theta::RemoveLastUsedCVIDRec() " << e.what() << "- Exception opening/reading/closing file\n" << std::endl;
        std::exit(1);
    }
    catch(const std::exception& e)
    {
        std::cerr << "Theta::RemoveLastUsedCVIDRec() " << e.what() << " - Exception\n";
        std::exit(1);
    }
    // catch (std::bad_alloc& e)
    // {
    //     std::cout << "Theta::RemoveLastUsedCVIDRec() " << e.what() << " bad allocation" << std::endl;
    //     std::exit(1);
    // }
}
*/

/*
bool Theta::AppendUsedCVIDRec(UsedCVIDRec parUsedCVIDRec)
{
    std::fstream ThetaHeaderFPtr;
    ThetaHeaderFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    std::fstream UsedCVFPtr;
    UsedCVFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    unsigned long long NoOfUsedContactVectorsRead;
    try
    {
        UsedCVFPtr.open(UsedCVListFileName, ios::in | ios::binary);
        if (UsedCVFPtr.fail()) throw UsedCVListFileName;  // the exception being checked   
        
        UsedCVFPtr.read((char *)&NoOfUsedContactVectorsRead, sizeof(NoOfUsedContactVectorsRead));
        if(NoOfUsedContactVectors != NoOfUsedContactVectorsRead)
        {
            std::cout << "Error in Theta::AppendUsedCVIDRec() - mismatch in the record count" << std::endl;
            std::exit(1);
        }
        UsedCVFPtr.close();

        UsedCVFPtr.open(UsedCVListFileName, ios::in | ios::out | ios::binary);
        if (UsedCVFPtr.fail()) throw UsedCVListFileName;  // the exception being checked   

        UsedCVFPtr.seekp(0, ios::end);
        UsedCVFPtr.write((char *)&parUsedCVIDRec, sizeof(parUsedCVIDRec));
        
        NoOfUsedContactVectors++;
        UsedCVFPtr.seekp(0,ios::beg);
        UsedCVFPtr.write((char *)&NoOfUsedContactVectors, sizeof(NoOfUsedContactVectors));
        UsedCVFPtr.close();

        ThetaHeaderFPtr.open(ThetaFileHeaderName, ios::in | ios::binary);
        if (ThetaHeaderFPtr.fail()) throw ThetaFileHeaderName;  // the exception being checked
        ThetaHeaderFPtr.close();

        ThetaHeaderFPtr.open(ThetaFileHeaderName, ios::in | ios::out | ios::binary);
        if (ThetaHeaderFPtr.fail()) throw ThetaFileHeaderName;  // the exception being checked

        ThetaHeaderFPtr.seekp(0, ios::end);
        ThetaHeaderFPtr.write((char *)this, sizeof(Theta));
        ThetaHeaderFPtr.close();
        return true;
    }
    catch (std::fstream::failure &e)
    {
        std::cerr << "Theta::AppendUsedCVRec() " << e.what() << "- Exception opening/reading/closing file\n" << std::endl;
        std::exit(1);
    }
    catch(const std::exception& e)
    {
        std::cerr << "Theta::AppendUsedCVRec() " << e.what() << " - Exception\n";
        std::exit(1);
    }
    // catch (std::bad_alloc& e)
    // {
    //     std::cout << "Theta::AppendUsedCVRec() " << e.what() << " bad allocation" << std::endl;
    //     std::exit(1);
    // }
}
*/

//****************************************************************************************
//*********************************** UsedCVList Library **************************************
//****************************************************************************************
/*
    UsedCVIDRec::UsedCVIDRec()
    {
        CVID = 0;
        UID = 0;
        OvFlag1 = false;
        OvFlag2 = false;
        UpdateFlag = false;
    }
    
    UsedCVIDRec::UsedCVIDRec(unsigned long long parCVID, unsigned long parUID1,unsigned long parUID2 
    bool parOvFlag1,bool parOvFlag2, bool parUpdateFlag)
    {
        CVID = parCVID;
        UID1 = parUID1;
        OvFlag1 = parOvFlag1;
        UID2 = parUID2;
        OvFlag2 = parOvFlag2;
        UpdateFlag = parUpdateFlag;
    }

    ostream& operator<<(ostream& parOut, const UsedCVIDRec& parUCVIDRec)
    {
        parOut<<"("<<parUCVIDRec.CVID<<")("<<parUCVIDRec.UID<<")(";
        if(parUCVIDRec.OvFlag1) parOut<<"1"; else parOut<<"0";
        parOut<<")(";
        if(parUCVIDRec.OvFlag2) parOut<<"1"; else parOut<<"0";
        parOut<<")(";
        if(parUCVIDRec.UpdateFlag) parOut<<"1"; else parOut<<"0";
        parOut<<")"<<std::endl;
        return parOut;
    }
    unsigned long long UsedCVIDRec::GetCVID()
    {
        return CVID;
    }
    bool UsedCVIDRec::SetCVID(unsigned long long parCVID)
    {
        if(parCVID < 0) return false;
        CVID = parCVID;
        return true;
    }
    unsigned long UsedCVIDRec::GetUID1()
    {
        return UID1;
    }
    bool UsedCVIDRec::SetUID1(unsigned long parUID)
    {
        if(parUID < 0) return false;
        UID1 = parUID;
        return true;
    }

    unsigned long UsedCVIDRec::GetUID2()
    {
        return UID2;
    }
    bool UsedCVIDRec::SetUID2(unsigned long parUID)
    {
        if(parUID < 0) return false;
        UID2 = parUID;
        return true;
    }

    bool UsedCVIDRec::GetOvFlag1()
    {
        return OvFlag1;
    }
    void UsedCVIDRec::SetOvFlag1(bool parOvFlag)
    {
        OvFlag1 = parOvFlag;
    }

    bool UsedCVIDRec::GetOvFlag2()
    {
        return OvFlag2;
    }
    void UsedCVIDRec::SetOvFlag2(bool parOvFlag)
    {
        OvFlag2 = parOvFlag;
    }
    unsigned int UsedCVIDRec::Size()
    {
        return sizeof(UsedCVIDRec);
    }
    bool UsedCVIDRec::GetUpdateFlag()
    {
        return UpdateFlag;
    }
    void UsedCVIDRec::SetUpdateFlag(bool parUpdateFlag)
    {
        UpdateFlag = parUpdateFlag;
    }
*/
//*********************************** End of UsedCVList Library *****************************

//****************************************************************************************
//*********************************** UsedCVList Library **************************************
//****************************************************************************************
/*
    UsedCVIDRec::UsedCVIDRec()
    {
        CVID = 0;
        UID = 0;
        OvFlag1 = false;
        OvFlag2 = false;
        UpdateFlag = false;
    }
    
    UsedCVIDRec::UsedCVIDRec(unsigned long long parCVID, unsigned long parUID1,unsigned long parUID2 
    bool parOvFlag1,bool parOvFlag2, bool parUpdateFlag)
    {
        CVID = parCVID;
        UID1 = parUID1;
        OvFlag1 = parOvFlag1;
        UID2 = parUID2;
        OvFlag2 = parOvFlag2;
        UpdateFlag = parUpdateFlag;
    }

    ostream& operator<<(ostream& parOut, const UsedCVIDRec& parUCVIDRec)
    {
        parOut<<"("<<parUCVIDRec.CVID<<")("<<parUCVIDRec.UID<<")(";
        if(parUCVIDRec.OvFlag1) parOut<<"1"; else parOut<<"0";
        parOut<<")(";
        if(parUCVIDRec.OvFlag2) parOut<<"1"; else parOut<<"0";
        parOut<<")(";
        if(parUCVIDRec.UpdateFlag) parOut<<"1"; else parOut<<"0";
        parOut<<")"<<std::endl;
        return parOut;
    }
    unsigned long long UsedCVIDRec::GetCVID()
    {
        return CVID;
    }
    bool UsedCVIDRec::SetCVID(unsigned long long parCVID)
    {
        if(parCVID < 0) return false;
        CVID = parCVID;
        return true;
    }
    unsigned long UsedCVIDRec::GetUID1()
    {
        return UID1;
    }
    bool UsedCVIDRec::SetUID1(unsigned long parUID)
    {
        if(parUID < 0) return false;
        UID1 = parUID;
        return true;
    }

    unsigned long UsedCVIDRec::GetUID2()
    {
        return UID2;
    }
    bool UsedCVIDRec::SetUID2(unsigned long parUID)
    {
        if(parUID < 0) return false;
        UID2 = parUID;
        return true;
    }

    bool UsedCVIDRec::GetOvFlag1()
    {
        return OvFlag1;
    }
    void UsedCVIDRec::SetOvFlag1(bool parOvFlag)
    {
        OvFlag1 = parOvFlag;
    }

    bool UsedCVIDRec::GetOvFlag2()
    {
        return OvFlag2;
    }
    void UsedCVIDRec::SetOvFlag2(bool parOvFlag)
    {
        OvFlag2 = parOvFlag;
    }
    unsigned int UsedCVIDRec::Size()
    {
        return sizeof(UsedCVIDRec);
    }
    bool UsedCVIDRec::GetUpdateFlag()
    {
        return UpdateFlag;
    }
    void UsedCVIDRec::SetUpdateFlag(bool parUpdateFlag)
    {
        UpdateFlag = parUpdateFlag;
    }
*/
//*********************************** End of UsedCVList Library *****************************


bool Phi::AddPhiRec(unsigned long long parNoOfPhiRecOvToAdd){
    if(parNoOfPhiRecOvToAdd <1){
        std::cout<<"Error in Phi::AddPhiRec()- invalid number Phi Overflow record to add"<<std::endl;
        return false;
    }
    std::fstream PhiHeaderFPtr;
    PhiHeaderFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    std::fstream PhiFPtr;
    PhiFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    std::fstream AvailListPhiOvFPtr;
    AvailListPhiOvFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);

    PhiRecOverflow R;
    unsigned long long i, NoOfPhiRecRead,NoOfPhiAvailOvRecRead,OvRecIndex;

    try {
        PhiHeaderFPtr.open(PhiFileHeaderName, ios::in | ios::binary);
        if (PhiHeaderFPtr.fail()) throw PhiFileHeaderName;  // the exception being checked

        PhiHeaderFPtr.read((char*)this, sizeof(Phi));
        PhiHeaderFPtr.close();

        AvailListPhiOvFPtr.open(PhiOvAvailListFileName, ios::in | ios::binary);
        if (AvailListPhiOvFPtr.fail()) throw PhiOvAvailListFileName;  // the exception being checked

        AvailListPhiOvFPtr.read((char*)&NoOfPhiAvailOvRecRead, sizeof(NoOfPhiAvailOvRecRead));
        if (NoOfPhiAvailOvRec != NoOfPhiAvailOvRecRead){
            AvailListPhiOvFPtr.close();
            std::cout << "Error in Phi::Phi() " << " mismatch in the record count" << std::endl;
            std::exit(1);
        }
        AvailListPhiOvFPtr.close();

        PhiFPtr.open(PhiFileName, ios::in | ios::binary);
        if (PhiFPtr.fail()) throw PhiFileName;  // the exception being checked

        PhiFPtr.read((char*)&NoOfPhiRecRead, sizeof(NoOfPhiRecRead));
        if (NoOfPhiRecRead != NoOfPhiRec){
            PhiFPtr.close();
            std::cout << "Error in Phi::Phi() " << " mismatch in the record count" << std::endl;
            std::exit(1);
        }

        PhiFPtr.open(PhiFileName, ios::in | ios::out | ios::binary);
        if (PhiFPtr.fail()) throw PhiFileName;  // the exception being checked

        AvailListPhiOvFPtr.open(PhiOvAvailListFileName, ios::in | ios::out | ios::binary);
        if (AvailListPhiOvFPtr.fail()) throw PhiOvAvailListFileName;  // the exception being checked

        PhiFPtr.seekg(0, ios::end);
        AvailListPhiOvFPtr.seekg(0, ios::end);
        
        R.SetDelFlag(true);
        for (i = 0; i < parNoOfPhiRecOvToAdd; i++){
            R.SetNext(Avail);
            PhiFPtr.write((char*)&R, sizeof(R));
            OvRecIndex = NoOfPhiOvRec + i;
            AvailListPhiOvFPtr.write((char *)&OvRecIndex, sizeof(OvRecIndex));
            Avail = OvRecIndex;
        }

        PhiFPtr.close();
        NoOfPhiOvRec = NoOfPhiOvRec + parNoOfPhiRecOvToAdd;
        NoOfPhiAvailOvRec = NoOfPhiAvailOvRec + parNoOfPhiRecOvToAdd;
        AvailListPhiOvFPtr.seekg(0, ios::beg);
        AvailListPhiOvFPtr.write((char*)&NoOfPhiAvailOvRec, sizeof(NoOfPhiAvailOvRec));
        AvailListPhiOvFPtr.close();

        PhiHeaderFPtr.open(PhiFileHeaderName, ios::in | ios::out | ios::binary);
        if (PhiHeaderFPtr.fail()) throw PhiFileHeaderName;  // the exception being checked

        PhiHeaderFPtr.write((char*)this, sizeof(Phi));
        PhiHeaderFPtr.close();
        return true;
    }
    catch (std::fstream::failure &e){
        std::cerr << "Phi::AddPhiRec(parNoOfPhiRecOverflow)  - Exception opening/reading/closing file\n";
        std::exit(1);
    }
    catch (std::string e){
        std::cout << "Phi::AddPhiRec(parNoOfPhiRecOverflow) " << e << " error in opening/creating" << std::endl;
        std::exit(1);
    }
    catch (std::out_of_range& e){
        std::cout << "Phi::AddPhiRec(parNoOfPhiRecOverflow) " << e.what() << " Not in range" << std::endl;
        std::exit(1);
    }
    catch (std::bad_alloc& e){
        std::cout << "Phi::AddPhiRec(parNoOfPhiRecOverflow) " << e.what() << " bad allocation" << std::endl;
        std::exit(1);
    }
    catch (std::exception& e){
        std::cout << "Phi::AddPhiRec(parNoOfPhiRecOverflow) " << e.what() << "Exception occur" << std::endl;
        std::exit(1);
    }
}

bool Phi::RemovePhiRec(unsigned long long parNoOfPhiRecOverflow){
    return true;
}


/*
bool Theta::ResetUsedCVIDList()
{
return true;
}
*/

/*
bool Theta::ExtractUnUsedCVIDList()
{
    std::fstream ThetaHeaderFPtr;
    ThetaHeaderFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    std::fstream UsedCVFPtr;
    UsedCVFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    std::fstream TempUsedCVFPtr;
    TempUsedCVFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);
    std::fstream UnUsedCVFPtr;
    UnUsedCVFPtr.exceptions(std::fstream::failbit | std::fstream::badbit);

    #ifdef _WIN32
        char TempUsedCVListFileName[40] = "C:\\DCTSystem\\Data\\TempUsedCVList.bin";
        char UnUsedCVListFileName[38] = "C:\\DCTSystem\\Data\\UnUsedCVList.bin";
    #elif defined __linux__
        char TempUsedCVListFileName[47] = "/home/gautam/DCTSystem/Data/TempUsedCVList.bin";
        char UnUsedCVListFileName[45] = "/home/gautam/DCTSystem/Data/UnUsedCVList.bin";
    #endif
      long long NoOfUsedContactVectorsRead,Pos;
      long long NoOfUnUsedContactVectors=0;
    UsedCVIDRec R;
    try
    {
        TempUsedCVFPtr.open(TempUsedCVListFileName, ios::out | ios::binary);
        if (TempUsedCVFPtr.fail()) throw TempUsedCVListFileName;  // the exception being checked   

        UnUsedCVFPtr.open(UnUsedCVListFileName, ios::out | ios::binary);
        if (UnUsedCVFPtr.fail()) throw UnUsedCVListFileName;  // the exception being checked   

        UsedCVFPtr.open(UsedCVListFileName, ios::in | ios::binary);
        if (UsedCVFPtr.fail()) throw UsedCVListFileName;  // the exception being checked   
        
        UsedCVFPtr.read((char *)&NoOfUsedContactVectorsRead, sizeof(NoOfUsedContactVectorsRead));
        UsedCVFPtr.close();
        if(NoOfUsedContactVectors != NoOfUsedContactVectorsRead)
        {
            UnUsedCVFPtr.close();
            TempUsedCVFPtr.close();
            std::cout << "Error in Theta::ExtractUnUsedCVIDList() - mismatch in the record count" << std::endl;
            std::exit(1);
        }
        
        UsedCVFPtr.open(UsedCVListFileName, ios::in | ios::out | ios::binary);
        if (UsedCVFPtr.fail()) throw UsedCVListFileName;  // the exception being checked   

        TempUsedCVFPtr.seekp(0,ios::beg);
        TempUsedCVFPtr.write((char *)&NoOfUsedContactVectors, sizeof(NoOfUsedContactVectors));

        UnUsedCVFPtr.seekp(0, ios::beg);
        UnUsedCVFPtr.write((char *)&NoOfUnUsedContactVectors, sizeof(NoOfUnUsedContactVectors));

        while(NoOfUsedContactVectorsRead>0)
        {
            Pos = sizeof(NoOfUsedContactVectorsRead) + (NoOfUsedContactVectorsRead-1)*R.Size();
            UsedCVFPtr.seekg(Pos, ios::beg);
            UsedCVFPtr.read((char *)&R, sizeof(R));
            NoOfUsedContactVectorsRead--;
            if(R.GetUpdateFlag())
            {
                TempUsedCVFPtr.write((char *)&R, sizeof(R));
            }
            else
            {
                UnUsedCVFPtr.write((char *)&R, sizeof(R));
                NoOfUnUsedContactVectors++;
            }
        }
        UsedCVFPtr.close();
        
        UnUsedCVFPtr.seekp(0, ios::beg);
        UnUsedCVFPtr.write((char *)&NoOfUnUsedContactVectors, sizeof(NoOfUnUsedContactVectors));
        UnUsedCVFPtr.close();
        NoOfUsedContactVectors = NoOfUsedContactVectors - NoOfUnUsedContactVectors;
        
        TempUsedCVFPtr.seekp(0,ios::end);
        TempUsedCVFPtr.write((char *)&NoOfUsedContactVectors,sizeof(NoOfUsedContactVectors));
        TempUsedCVFPtr.close();

        ThetaHeaderFPtr.open(ThetaFileHeaderName, ios::in | ios::binary);
        if (ThetaHeaderFPtr.fail()) throw ThetaFileHeaderName;  // the exception being checked
        ThetaHeaderFPtr.close();

        ThetaHeaderFPtr.open(ThetaFileHeaderName, ios::in | ios::out | ios::binary);
        if (ThetaHeaderFPtr.fail()) throw ThetaFileHeaderName;  // the exception being checked

        ThetaHeaderFPtr.seekp(0, ios::end);
        ThetaHeaderFPtr.write((char *)this, sizeof(Theta));
        ThetaHeaderFPtr.close();

        int Status=remove(UsedCVListFileName);
        if(Status == 0)
            puts ( "File successfully removed" );
        else
        {
            perror( "Error in removing file" );
            return false;
        }
        Status = rename(TempUsedCVListFileName, UsedCVListFileName);
        if(Status==0)
            puts("File successfully renamed");
        else
        {
            perror("Error in renaming file");
            return false;
        }
        return true;
    }
    catch (std::fstream::failure &e)
    {
        std::cerr << "Theta::ExtractUnUsedCVIDList() " << e.what() << "- Exception opening/reading/closing file\n" << std::endl;
        std::exit(1);
    }
    catch(const std::exception& e)
    {
        std::cerr << "Theta::ExtractUnUsedCVIDList() " << e.what() << " - Exception\n";
        std::exit(1);
    }
    // catch (std::bad_alloc& e)
    // {
    //     std::cout << "Theta::ExtractUnUsedCVIDList() " << e.what() << " bad allocation" << std::endl;
    //     std::exit(1);
    // }    
}
*/

bool Phi::Update(long parSID, long parDID, std::vector<bool> parVector, 
    int parCCRear, int parCCFront, int parDCRear, int parDCFront){
    if ((parSID < 0L || parDID < 0L) || (parSID >= N || parDID >= N)){
        std::cout<<"Error in Phi::GetCVID()- Invalid user ID(s)"<<std::endl;
        return false;
    }
    long long CVID;
    try{
        if (!GetCVID(parSID, parDID, CVID)){
            std::cout << "Contact(" << parSID << "," << parDID << ")" << "not found" << std::endl;
            return false;
        }
        
        return true;
    }
    catch (std::out_of_range& e){
        std::cout << "Phi::Update(parSID,parDID,...) " << e.what() << " Not in range" << std::endl;
        std::exit(1);
    }
    catch (std::bad_alloc& e){
        std::cout << "Phi::Update(parSID,parDID,...) " << e.what() << " bad allocation" << std::endl;
        std::exit(1);
    }
    catch (std::exception& e){
        std::cout << "Phi::Update(parSID,parDID,...) " << e.what() << "Exception occur" << std::endl;
        std::exit(1);
    }
}


